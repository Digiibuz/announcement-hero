
// This file is automatically generated. Do not edit it directly.
import { createClient, SupabaseClient } from '@supabase/supabase-js';
type Database = any; // Temporary type to avoid compilation errors

// URL de base Supabase - pas de clé sensible ici
const SUPABASE_URL = `https://rdwqedmvzicerwotjseg.supabase.co`;
const EDGE_FUNCTION_URL = `${SUPABASE_URL}/functions/v1/secure-client-config`;

// Variable pour stocker le client initialisé
let supabaseInstance: SupabaseClient<Database> | null = null;
let isInitializing = false;
let initializationPromise: Promise<boolean> | null = null;
let initAttempts = 0;
const MAX_INIT_ATTEMPTS = 5;
const MAX_RETRIES = 3;
const API_TIMEOUT_MS = 10000; // 10 secondes

// Fonction pour retarder avec backoff exponentiel
const delay = (attempt: number) => {
  const backoff = Math.min(Math.pow(2, attempt) * 300, 5000);
  return new Promise(resolve => setTimeout(resolve, backoff));
};

// Fonction pour effectuer une requête avec timeout
const fetchWithTimeout = async (url: string, options: RequestInit = {}, timeoutMs = API_TIMEOUT_MS): Promise<Response> => {
  const controller = new AbortController();
  const { signal } = controller;
  
  const timeout = setTimeout(() => {
    controller.abort();
  }, timeoutMs);
  
  try {
    console.log(`Fetching ${url} with options:`, options);
    const response = await fetch(url, { ...options, signal });
    console.log(`Response status: ${response.status}`);
    return response;
  } catch (error: any) {
    console.error(`Fetch error: ${error.message}`);
    if (error.name === 'AbortError') {
      throw new Error(`Requête dépassée (timeout: ${timeoutMs}ms)`);
    }
    throw error;
  } finally {
    clearTimeout(timeout);
  }
};

// Création initiale du client avec une clé temporaire (sera remplacée)
const createSecureClient = () => {
  if (supabaseInstance) {
    return supabaseInstance;
  }

  console.log("Création d'un client temporaire");
  
  // Client temporaire avec clé placeholder
  supabaseInstance = createClient<Database>(
    SUPABASE_URL,
    'temporary_placeholder_key',
    {
      auth: {
        persistSession: true,
        storage: localStorage,
        autoRefreshToken: true,
        detectSessionInUrl: true
      }
    }
  );
  
  return supabaseInstance;
};

// Créer le client avec des configurations sécurisées
export const supabase = createSecureClient();

// Helper function for type casting
export function typedData<T>(data: unknown): T {
  return data as T;
}

// Verrou pour éviter les initialisations concurrentes
let initLock = false;

// Initialise le client avec les vraies informations d'authentification
export const initializeSecureClient = async (forceReset = false): Promise<boolean> => {
  // Tracer les données d'environnement pour le débogage
  console.log(`[initializeSecureClient] Environnement: ${process.env.NODE_ENV}`);
  console.log(`[initializeSecureClient] Force reset: ${forceReset}`);
  console.log(`[initializeSecureClient] URL: ${SUPABASE_URL}`);
  
  // Si demandé, forcer la réinitialisation complète
  if (forceReset) {
    console.log('Réinitialisation forcée du client Supabase');
    await cleanupAuthState();
    supabaseInstance = null;
    initializationPromise = null;
    initLock = false;
    localStorage.removeItem('auth-needs-reset');
    localStorage.removeItem('auth-retry-needed');
  }

  // Verrouillage pour éviter les appels concurrents
  if (initLock) {
    console.log('Initialisation déjà en cours, attente...');
    return initializationPromise || false;
  }

  // Si initialisation déjà en cours, retourner la promesse existante
  if (initializationPromise && !forceReset) {
    return initializationPromise;
  }
  
  initLock = true;
  isInitializing = true;
  console.log('Début de l\'initialisation du client Supabase');
  
  // Incrémenter le compteur de tentatives
  initAttempts++;
  
  // Délai plus long après plusieurs tentatives
  if (initAttempts > 1) {
    console.warn(`Tentative d'initialisation ${initAttempts}/${MAX_INIT_ATTEMPTS} - Augmentation du délai`);
    await delay(initAttempts);
  }
  
  initializationPromise = new Promise(async (resolve) => {
    try {
      // Implémentation avec retry
      let retries = 0;
      let success = false;
      let error;
      
      while (retries < MAX_RETRIES && !success) {
        try {
          console.log(`Récupération de la configuration sécurisée (tentative ${retries + 1}/${MAX_RETRIES})...`);
          
          // Mode sans cache forcé pour éviter les problèmes avec les CDN
          const cacheKiller = new Date().getTime();
          const randomId = Math.random().toString(36).substring(2, 15);
          
          // Récupération via Edge Function avec debug headers
          const response = await fetchWithTimeout(
            `${EDGE_FUNCTION_URL}?t=${cacheKiller}&r=${randomId}`,
            {
              method: 'GET',
              headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                'X-Client-Info': `supabase-js-debug/v${cacheKiller}`,
                'X-Web-Security': 'allow',
                'X-Retry-Attempt': `${retries + 1}`,
                'X-Client-Id': randomId,
                'User-Agent': navigator.userAgent
              },
              credentials: 'omit',
              cache: 'no-store',
              mode: 'cors'
            },
            15000 // Timeout plus long (15 secondes)
          );
          
          if (!response.ok) {
            console.error('Erreur HTTP:', response.status, response.statusText);
            
            // Récupérer le corps de la réponse pour le débogage
            let responseText = '';
            try {
              responseText = await response.text();
            } catch (textError) {
              responseText = 'Impossible de lire la réponse';
            }
            
            error = new Error(`Erreur HTTP ${response.status}: ${response.statusText}`);
            console.error('Détails de la réponse:', responseText);
            
            retries++;
            if (retries < MAX_RETRIES) {
              await delay(retries);
              continue;
            } else {
              throw error;
            }
          }
          
          let data;
          try {
            data = await response.json();
          } catch (jsonError) {
            console.error('Erreur de parsing JSON:', jsonError);
            error = new Error('Réponse invalide du serveur');
            retries++;
            if (retries < MAX_RETRIES) {
              await delay(retries);
              continue;
            } else {
              throw error;
            }
          }
          
          console.log("Réponse de l'Edge Function:", { 
            success: data.success, 
            timestamp: data.timestamp,
            hasKey: !!data.anonKey,
            hasUrl: !!data.url,
            clientInfo: data.clientInfo,
            headers: data.headers
          });
          
          const { anonKey, url } = data;
          
          if (!anonKey) {
            error = new Error('Clé API non trouvée dans la réponse');
            console.error(error.message, data);
            
            retries++;
            if (retries < MAX_RETRIES) {
              await delay(retries);
              continue;
            } else {
              throw error;
            }
          }
          
          // Recréer un nouveau client avec la clé récupérée
          console.log("Création d'un nouveau client Supabase avec la clé récupérée");
          supabaseInstance = createClient<Database>(
            url || SUPABASE_URL,
            anonKey,
            {
              auth: {
                persistSession: true,
                storage: localStorage,
                autoRefreshToken: true,
                detectSessionInUrl: true
              }
            }
          );
          
          console.log('Client Supabase initialisé avec succès');
          success = true;
        } catch (attemptError) {
          error = attemptError;
          console.error(`Erreur d'initialisation (tentative ${retries + 1}):`, attemptError);
          retries++;
          if (retries < MAX_RETRIES) {
            await delay(retries);
          }
        }
      }
      
      if (!success) {
        console.error("Échec de toutes les tentatives d'initialisation:", error);
        localStorage.setItem('auth-needs-reset', 'true');
        initLock = false;
        isInitializing = false;
        initializationPromise = null;
        resolve(false);
        return;
      }
      
      // Test post-initialisation
      try {
        const { data, error } = await supabaseInstance.auth.getSession();
        if (error) {
          console.warn('Test post-initialisation: Erreur session:', error);
        } else {
          console.log('Test post-initialisation réussi:', !!data.session);
          localStorage.removeItem('auth-needs-reset');
        }
      } catch (e) {
        console.error('Erreur lors du test post-initialisation:', e);
      }
      
      initAttempts = 0;
      initLock = false;
      isInitializing = false;
      resolve(true);
    } catch (error) {
      console.error('Erreur critique:', error);
      localStorage.setItem('auth-needs-reset', 'true');
      initLock = false;
      isInitializing = false;
      initializationPromise = null;
      resolve(false);
    }
  });
  
  return initializationPromise;
};

// Fonction asynchrone qui attend l'initialisation
export const withInitializedClient = async <T>(action: () => Promise<T>): Promise<T> => {
  console.log("withInitializedClient: Début");
  const success = await initializeSecureClient();
  
  if (!success) {
    console.warn('Tentative avec client non initialisé - réessai forcé...');
    
    initializationPromise = null;
    const retrySuccess = await initializeSecureClient(true);
    
    if (!retrySuccess) {
      throw new Error('Impossible d\'initialiser le client après plusieurs tentatives');
    }
  }
  
  console.log("withInitializedClient: Client prêt, exécution de l'action");
  return action();
};

// Fonction pour nettoyer l'état d'authentification
export const cleanupAuthState = async () => {
  console.log("Nettoyage complet de l'état d'authentification");
  
  // Supprimer toutes les clés liées à l'authentification
  Object.keys(localStorage).forEach((key) => {
    if (key.startsWith('supabase.auth.') || key.includes('sb-') || key.includes('auth-')) {
      console.log(`Suppression de la clé: ${key}`);
      localStorage.removeItem(key);
    }
  });

  // Faire de même pour sessionStorage
  Object.keys(sessionStorage).forEach((key) => {
    if (key.startsWith('supabase.auth.') || key.includes('sb-') || key.includes('auth-')) {
      console.log(`Suppression de la clé de session: ${key}`);
      sessionStorage.removeItem(key);
    }
  });

  // Réinitialiser le client
  supabaseInstance = null;
  initializationPromise = null;
  initLock = false;
  isInitializing = false;
  
  // Attendre avant réinitialisation
  await new Promise(resolve => setTimeout(resolve, 100));
  
  console.log("État d'authentification nettoyé avec succès");
  return initializeSecureClient(true);
};

// Vérifie si réinitialisation nécessaire
export const needsAuthReset = (): boolean => {
  return localStorage.getItem('auth-needs-reset') === 'true';
};
