
// This file is automatically generated. Do not edit it directly.
import { createClient, SupabaseClient } from '@supabase/supabase-js';
type Database = any; // Temporary type to avoid compilation errors

// Base URL - no sensitive key here
const SUPABASE_URL = `https://rdwqedmvzicerwotjseg.supabase.co`;
const EDGE_FUNCTION_URL = `${SUPABASE_URL}/functions/v1/secure-client-config`;

// Variable to store initialized client
let supabaseInstance: SupabaseClient<Database> | null = null;
let isInitializing = false;
let initializationPromise: Promise<boolean> | null = null;
let initAttempts = 0;
const MAX_INIT_ATTEMPTS = 5;
const MAX_RETRIES = 5; // Increased max retries
const API_TIMEOUT_MS = 15000; // Increased to 15 seconds

// Debug storage for troubleshooting
const debugStorage: Record<string, any> = {};
const addDebugInfo = (key: string, value: any) => {
  debugStorage[key] = value;
  console.log(`[DEBUG] ${key}:`, value);
};

// Function to delay with exponential backoff
const delay = (attempt: number) => {
  const backoff = Math.min(Math.pow(2, attempt) * 300, 10000); // More aggressive backoff
  return new Promise(resolve => setTimeout(resolve, backoff));
};

// Function to perform request with timeout
const fetchWithTimeout = async (url: string, options: RequestInit = {}, timeoutMs = API_TIMEOUT_MS): Promise<Response> => {
  const controller = new AbortController();
  const { signal } = controller;
  
  const timeoutId = setTimeout(() => {
    controller.abort();
  }, timeoutMs);
  
  try {
    const requestId = Math.random().toString(36).substring(2, 15);
    addDebugInfo(`fetch-start-${requestId}`, { 
      url, 
      options: { ...options, headers: options.headers }, 
      time: new Date().toISOString() 
    });
    
    const response = await fetch(url, { ...options, signal });
    
    addDebugInfo(`fetch-complete-${requestId}`, { 
      status: response.status,
      statusText: response.statusText,
      time: new Date().toISOString()
    });
    
    return response;
  } catch (error: any) {
    addDebugInfo(`fetch-error`, { 
      message: error.message,
      name: error.name,
      time: new Date().toISOString() 
    });
    
    if (error.name === 'AbortError') {
      throw new Error(`Request timeout (${timeoutMs}ms)`);
    }
    throw error;
  } finally {
    clearTimeout(timeoutId);
  }
};

// Initial client creation with temporary key (will be replaced)
const createSecureClient = () => {
  if (supabaseInstance) {
    return supabaseInstance;
  }

  addDebugInfo('client-create-temp', { time: new Date().toISOString() });
  
  // Temporary client with placeholder key
  supabaseInstance = createClient<Database>(
    SUPABASE_URL,
    'temporary_placeholder_key',
    {
      auth: {
        persistSession: true,
        storage: localStorage,
        autoRefreshToken: true,
        detectSessionInUrl: true
      }
    }
  );
  
  return supabaseInstance;
};

// Create client with secure configurations
export const supabase = createSecureClient();

// Helper function for type casting
export function typedData<T>(data: unknown): T {
  return data as T;
}

// Lock to avoid concurrent initializations
let initLock = false;

// Initialize client with real authentication information
export const initializeSecureClient = async (forceReset = false): Promise<boolean> => {
  // Trace environment data for debugging
  addDebugInfo('init-env', {
    env: process.env.NODE_ENV,
    forceReset,
    url: SUPABASE_URL,
    time: new Date().toISOString()
  });
  
  // Force reset if requested
  if (forceReset) {
    addDebugInfo('force-reset', { time: new Date().toISOString() });
    await cleanupAuthState();
    supabaseInstance = null;
    initializationPromise = null;
    initLock = false;
    localStorage.removeItem('auth-needs-reset');
    localStorage.removeItem('auth-retry-needed');
    sessionStorage.removeItem('supabase.auth.token');
  }

  // Lock to avoid concurrent calls
  if (initLock) {
    addDebugInfo('init-lock-wait', { time: new Date().toISOString() });
    return initializationPromise || false;
  }

  // If initialization already in progress, return existing promise
  if (initializationPromise && !forceReset) {
    return initializationPromise;
  }
  
  initLock = true;
  isInitializing = true;
  addDebugInfo('init-start', { time: new Date().toISOString() });
  
  // Increment attempt counter
  initAttempts++;
  
  // Longer delay after multiple attempts
  if (initAttempts > 1) {
    addDebugInfo(`init-attempt-${initAttempts}`, { time: new Date().toISOString() });
    await delay(initAttempts);
  }
  
  initializationPromise = new Promise(async (resolve) => {
    try {
      // Implementation with retry
      let retries = 0;
      let success = false;
      let lastError;
      
      while (retries < MAX_RETRIES && !success) {
        try {
          addDebugInfo(`config-fetch-try-${retries + 1}`, { time: new Date().toISOString() });
          
          // Force no cache to avoid CDN problems
          const cacheKiller = new Date().getTime();
          const randomId = Math.random().toString(36).substring(2, 15);
          
          // Retrieve via Edge Function with debug headers
          const response = await fetchWithTimeout(
            `${EDGE_FUNCTION_URL}?t=${cacheKiller}&r=${randomId}`,
            {
              method: 'GET',
              headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                'X-Client-Info': `supabase-js-debug/v${cacheKiller}`,
                'X-Web-Security': 'allow',
                'X-Retry-Attempt': `${retries + 1}`,
                'X-Client-Id': randomId,
                'User-Agent': navigator.userAgent
              },
              credentials: 'omit',
              cache: 'no-store',
              mode: 'cors'
            },
            20000 // Longer timeout (20 seconds)
          );
          
          if (!response.ok) {
            const status = response.status;
            const statusText = response.statusText;
            addDebugInfo(`http-error-${retries}`, { status, statusText });
            
            // Get response body for debugging
            let responseText = '';
            try {
              responseText = await response.text();
            } catch (textError) {
              responseText = 'Unable to read response';
            }
            
            lastError = new Error(`HTTP Error ${status}: ${statusText}`);
            addDebugInfo('response-details', responseText);
            
            retries++;
            if (retries < MAX_RETRIES) {
              await delay(retries);
              continue;
            } else {
              throw lastError;
            }
          }
          
          let data;
          try {
            data = await response.json();
          } catch (jsonError) {
            addDebugInfo('json-parse-error', jsonError);
            lastError = new Error('Invalid server response');
            retries++;
            if (retries < MAX_RETRIES) {
              await delay(retries);
              continue;
            } else {
              throw lastError;
            }
          }
          
          addDebugInfo('edge-response', { 
            success: data.success, 
            timestamp: data.timestamp,
            hasKey: !!data.anonKey,
            hasUrl: !!data.url,
            clientInfo: data.clientInfo,
            requestId: data.requestId,
            clientId: data.clientId
          });
          
          const { anonKey, url } = data;
          
          if (!anonKey) {
            lastError = new Error('API key not found in response');
            addDebugInfo('api-key-missing', data);
            
            retries++;
            if (retries < MAX_RETRIES) {
              await delay(retries);
              continue;
            } else {
              throw lastError;
            }
          }
          
          // Create new client with retrieved key
          addDebugInfo('create-new-client', { time: new Date().toISOString() });
          supabaseInstance = createClient<Database>(
            url || SUPABASE_URL,
            anonKey,
            {
              auth: {
                persistSession: true,
                storage: localStorage,
                autoRefreshToken: true,
                detectSessionInUrl: true
              }
            }
          );
          
          addDebugInfo('client-init-success', { time: new Date().toISOString() });
          success = true;
        } catch (attemptError) {
          lastError = attemptError;
          addDebugInfo(`init-error-${retries}`, { 
            message: attemptError.message,
            time: new Date().toISOString() 
          });
          retries++;
          if (retries < MAX_RETRIES) {
            await delay(retries);
          }
        }
      }
      
      if (!success) {
        addDebugInfo('all-attempts-failed', { 
          error: lastError,
          time: new Date().toISOString() 
        });
        localStorage.setItem('auth-needs-reset', 'true');
        initLock = false;
        isInitializing = false;
        initializationPromise = null;
        resolve(false);
        return;
      }
      
      // Post-initialization test
      try {
        addDebugInfo('post-init-test', { time: new Date().toISOString() });
        const { data, error } = await supabaseInstance.auth.getSession();
        if (error) {
          addDebugInfo('post-init-session-error', { 
            error: error.message,
            time: new Date().toISOString() 
          });
        } else {
          addDebugInfo('post-init-test-success', { 
            hasSession: !!data.session,
            time: new Date().toISOString() 
          });
          localStorage.removeItem('auth-needs-reset');
        }
      } catch (e) {
        addDebugInfo('post-init-test-exception', {
          error: e.message,
          time: new Date().toISOString()
        });
      }
      
      initAttempts = 0;
      initLock = false;
      isInitializing = false;
      resolve(true);
    } catch (error) {
      addDebugInfo('critical-error', {
        message: error.message,
        stack: error.stack,
        time: new Date().toISOString()
      });
      localStorage.setItem('auth-needs-reset', 'true');
      initLock = false;
      isInitializing = false;
      initializationPromise = null;
      resolve(false);
    }
  });
  
  return initializationPromise;
};

// Function that waits for initialization
export const withInitializedClient = async <T>(action: () => Promise<T>): Promise<T> => {
  addDebugInfo('with-init-client', { time: new Date().toISOString() });
  const success = await initializeSecureClient();
  
  if (!success) {
    addDebugInfo('client-not-initialized', { time: new Date().toISOString() });
    
    // Clear initialization promise and retry with force reset
    initializationPromise = null;
    const retrySuccess = await initializeSecureClient(true);
    
    if (!retrySuccess) {
      throw new Error('Unable to initialize client after multiple attempts');
    }
  }
  
  addDebugInfo('client-ready-for-action', { time: new Date().toISOString() });
  return action();
};

// Function to clean up authentication state
export const cleanupAuthState = async () => {
  addDebugInfo('cleanup-start', {
    localStorage: Object.keys(localStorage),
    sessionStorage: Object.keys(sessionStorage),
    time: new Date().toISOString()
  });
  
  // Remove all authentication-related keys
  Object.keys(localStorage).forEach((key) => {
    if (key.startsWith('supabase.auth.') || key.includes('sb-') || key.includes('auth-')) {
      addDebugInfo(`remove-local-${key}`, { time: new Date().toISOString() });
      localStorage.removeItem(key);
    }
  });

  // Do the same for sessionStorage
  Object.keys(sessionStorage).forEach((key) => {
    if (key.startsWith('supabase.auth.') || key.includes('sb-') || key.includes('auth-')) {
      addDebugInfo(`remove-session-${key}`, { time: new Date().toISOString() });
      sessionStorage.removeItem(key);
    }
  });

  // Reset client
  supabaseInstance = null;
  initializationPromise = null;
  initLock = false;
  isInitializing = false;
  
  // Wait before reinitializing
  await new Promise(resolve => setTimeout(resolve, 500));
  
  addDebugInfo('cleanup-complete', { time: new Date().toISOString() });
  return initializeSecureClient(true);
};

// Check if reset needed
export const needsAuthReset = (): boolean => {
  return localStorage.getItem('auth-needs-reset') === 'true';
};

// Get debug information
export const getDebugInfo = (): Record<string, any> => {
  return { ...debugStorage };
};
