
// This file is automatically generated. Do not edit it directly.
import { createClient, SupabaseClient } from '@supabase/supabase-js';
type Database = any; // Temporary type to avoid compilation errors

// Base URL - no sensitive key here
const SUPABASE_URL = `https://rdwqedmvzicerwotjseg.supabase.co`;
const EDGE_FUNCTION_URL = `${SUPABASE_URL}/functions/v1/secure-client-config`;

// Variable to store initialized client
let supabaseInstance: SupabaseClient<Database> | null = null;
let isInitializing = false;
let initializationPromise: Promise<boolean> | null = null;
let initAttempts = 0;
const MAX_INIT_ATTEMPTS = 5;
const MAX_RETRIES = 10; // Increased retries for more persistence
const API_TIMEOUT_MS = 30000; // Increased to 30 seconds

// Debug storage for troubleshooting
const debugStorage: Record<string, any> = {};
const addDebugInfo = (key: string, value: any) => {
  const timestamp = new Date().toISOString();
  debugStorage[`${timestamp}_${key}`] = value;
  console.log(`[DEBUG] ${key}:`, value);
};

// Function to delay with exponential backoff
const delay = (attempt: number) => {
  const baseDelay = Math.min(Math.pow(2, attempt) * 300, 10000);
  const jitter = Math.random() * 300; // Add randomness to prevent thundering herd
  return new Promise(resolve => setTimeout(resolve, baseDelay + jitter));
};

// Function to perform request with timeout
const fetchWithTimeout = async (url: string, options: RequestInit = {}, timeoutMs = API_TIMEOUT_MS): Promise<Response> => {
  const controller = new AbortController();
  const { signal } = controller;
  
  const timeoutId = setTimeout(() => {
    controller.abort();
  }, timeoutMs);
  
  try {
    const requestId = Math.random().toString(36).substring(2, 15);
    const startTime = new Date().toISOString();
    addDebugInfo(`fetch-start-${requestId}`, { 
      url, 
      options: { ...options, headers: options.headers }, 
      time: startTime
    });
    
    // Add cache-busting parameters to URL
    const urlWithCacheBuster = new URL(url);
    urlWithCacheBuster.searchParams.append('nocache', Date.now().toString());
    urlWithCacheBuster.searchParams.append('uid', requestId);
    
    // Enhanced headers for better diagnostic tracking
    const enhancedHeaders = new Headers(options.headers || {});
    if (!enhancedHeaders.has('x-client-id')) {
      enhancedHeaders.set('x-client-id', requestId);
    }
    if (!enhancedHeaders.has('x-retry-attempt')) {
      enhancedHeaders.set('x-retry-attempt', '1');
    }
    
    // Ensure needed Cache-Control headers
    enhancedHeaders.set('Cache-Control', 'no-cache, no-store, must-revalidate');
    enhancedHeaders.set('Pragma', 'no-cache');
    
    // Apply enhanced headers
    options.headers = enhancedHeaders;
    
    const response = await fetch(urlWithCacheBuster.toString(), { 
      ...options, 
      signal,
      // Note: explicitly setting cache: 'no-store' here
      cache: 'no-store'
    });
    
    const endTime = new Date().toISOString();
    addDebugInfo(`fetch-complete-${requestId}`, { 
      status: response.status,
      statusText: response.statusText,
      time: endTime,
      duration: `${new Date().getTime() - new Date(startTime).getTime()}ms`
    });
    
    return response;
  } catch (error: any) {
    addDebugInfo(`fetch-error`, { 
      message: error.message,
      name: error.name,
      time: new Date().toISOString() 
    });
    
    if (error.name === 'AbortError') {
      throw new Error(`Request timeout (${timeoutMs}ms)`);
    }
    throw error;
  } finally {
    clearTimeout(timeoutId);
  }
};

// Initial client creation with temporary key (will be replaced)
const createSecureClient = () => {
  if (supabaseInstance) {
    return supabaseInstance;
  }

  addDebugInfo('client-create-temp', { time: new Date().toISOString() });
  
  try {
    // Temporary client with placeholder key
    supabaseInstance = createClient<Database>(
      SUPABASE_URL,
      'temporary_placeholder_key',
      {
        auth: {
          persistSession: true,
          storage: localStorage,
          autoRefreshToken: true,
          detectSessionInUrl: true
        }
      }
    );
    
    addDebugInfo('client-create-temp-success', { time: new Date().toISOString() });
  } catch (error: any) {
    addDebugInfo('client-create-temp-error', { 
      error: error.message,
      stack: error.stack,
      time: new Date().toISOString() 
    });
  }
  
  return supabaseInstance;
};

// Create client with secure configurations
export const supabase = createSecureClient();

// Helper function for type casting
export function typedData<T>(data: unknown): T {
  return data as T;
}

// Lock to avoid concurrent initializations
let initLock = false;

// Initialize client with real authentication information
export const initializeSecureClient = async (forceReset = false): Promise<boolean> => {
  // Record session start
  const startTime = new Date().toISOString();
  
  // Trace environment data for debugging
  addDebugInfo('init-env', {
    env: process.env.NODE_ENV,
    forceReset,
    url: SUPABASE_URL,
    time: startTime
  });
  
  // Force reset if requested
  if (forceReset) {
    addDebugInfo('force-reset', { time: startTime });
    await cleanupAuthState();
    supabaseInstance = null;
    initializationPromise = null;
    initLock = false;
    localStorage.removeItem('auth-needs-reset');
    localStorage.removeItem('auth-retry-needed');
    sessionStorage.removeItem('supabase.auth.token');
  }

  // Lock to avoid concurrent calls
  if (initLock) {
    addDebugInfo('init-lock-wait', { time: startTime });
    return initializationPromise || false;
  }

  // If initialization already in progress, return existing promise
  if (initializationPromise && !forceReset) {
    return initializationPromise;
  }
  
  initLock = true;
  isInitializing = true;
  addDebugInfo('init-start', { time: startTime });
  
  // Increment attempt counter
  initAttempts++;
  
  // Longer delay after multiple attempts
  if (initAttempts > 1) {
    addDebugInfo(`init-attempt-${initAttempts}`, { time: startTime });
    await delay(initAttempts);
  }
  
  initializationPromise = new Promise(async (resolve) => {
    try {
      // Implementation with retry
      let retries = 0;
      let success = false;
      let lastError;
      
      while (retries < MAX_RETRIES && !success) {
        try {
          const attemptTime = new Date().toISOString();
          addDebugInfo(`config-fetch-try-${retries + 1}`, { time: attemptTime });
          
          // Force no cache to avoid CDN problems
          const cacheKiller = new Date().getTime();
          const randomId = Math.random().toString(36).substring(2, 15);
          
          // Use fetch directly for better control and debugging
          const directFetchUrl = `${EDGE_FUNCTION_URL}?t=${cacheKiller}&r=${randomId}`;
          addDebugInfo(`direct-fetch-url`, { url: directFetchUrl });
          
          // Advanced diagnostic headers
          const headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-Client-Info': `client-direct/v${cacheKiller}`,
            'X-Web-Security': 'allow',
            'X-Retry-Attempt': `${retries + 1}`,
            'X-Client-Id': randomId,
            'User-Agent': navigator.userAgent,
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache'
          };
          
          addDebugInfo(`direct-fetch-headers`, headers);
          
          // Direct fetch with increased timeout
          const response = await fetchWithTimeout(
            directFetchUrl,
            {
              method: 'GET',
              headers,
              credentials: 'omit',
              cache: 'no-store',
              mode: 'cors'
            },
            30000 // 30 seconds timeout
          );
          
          addDebugInfo(`direct-fetch-response`, { 
            status: response.status, 
            statusText: response.statusText,
            headers: Object.fromEntries(response.headers.entries())
          });
          
          if (!response.ok) {
            const status = response.status;
            const statusText = response.statusText;
            addDebugInfo(`http-error-${retries}`, { status, statusText });
            
            // Get response body for debugging
            let responseText = '';
            try {
              responseText = await response.text();
            } catch (textError) {
              responseText = 'Unable to read response';
            }
            
            lastError = new Error(`HTTP Error ${status}: ${statusText}`);
            addDebugInfo('response-details', responseText);
            
            retries++;
            if (retries < MAX_RETRIES) {
              await delay(retries + 2); // Increase delay factor
              continue;
            } else {
              throw lastError;
            }
          }
          
          let data;
          try {
            data = await response.json();
          } catch (jsonError) {
            addDebugInfo('json-parse-error', jsonError);
            lastError = new Error('Invalid server response');
            retries++;
            if (retries < MAX_RETRIES) {
              await delay(retries);
              continue;
            } else {
              throw lastError;
            }
          }
          
          addDebugInfo('edge-response', { 
            success: data.success, 
            timestamp: data.timestamp,
            hasKey: !!data.anonKey,
            hasUrl: !!data.url,
            clientInfo: data.clientInfo,
            requestId: data.requestId,
            clientId: data.clientId,
            cacheKey: data.cacheKey
          });
          
          const { anonKey, url } = data;
          
          if (!anonKey) {
            lastError = new Error('API key not found in response');
            addDebugInfo('api-key-missing', { 
              responseData: { 
                ...data, 
                anonKey: data.anonKey ? "PRÉSENTE MAIS MASQUÉE" : "ABSENTE" 
              }
            });
            
            retries++;
            if (retries < MAX_RETRIES) {
              await delay(retries + 2);
              continue;
            } else {
              throw lastError;
            }
          }
          
          // Create new client with retrieved key
          addDebugInfo('create-new-client', { time: new Date().toISOString() });
          
          // Force destroy previous instance if exists
          if (supabaseInstance) {
            try {
              // Try to clean up any existing auth state
              await supabaseInstance.auth.signOut({ scope: 'global' });
            } catch (e) {
              // Ignore errors, we'll reset anyway
            }
          }
          
          // Create fresh instance
          supabaseInstance = createClient<Database>(
            url || SUPABASE_URL,
            anonKey,
            {
              auth: {
                persistSession: true,
                storage: localStorage,
                autoRefreshToken: true,
                detectSessionInUrl: true,
                flowType: 'implicit' // Explicitly setting flow type
              }
            }
          );
          
          addDebugInfo('client-init-success', { 
            time: new Date().toISOString(),
            clientOptions: {
              persistSession: true,
              autoRefreshToken: true,
              detectSessionInUrl: true,
              flowType: 'implicit'
            }
          });
          
          success = true;
        } catch (attemptError: any) {
          lastError = attemptError;
          addDebugInfo(`init-error-${retries}`, { 
            message: attemptError.message,
            time: new Date().toISOString() 
          });
          retries++;
          if (retries < MAX_RETRIES) {
            await delay(retries);
          }
        }
      }
      
      if (!success) {
        addDebugInfo('all-attempts-failed', { 
          error: lastError,
          time: new Date().toISOString() 
        });
        localStorage.setItem('auth-needs-reset', 'true');
        initLock = false;
        isInitializing = false;
        initializationPromise = null;
        resolve(false);
        return;
      }
      
      // Post-initialization test
      try {
        addDebugInfo('post-init-test', { time: new Date().toISOString() });
        const { data, error } = await supabaseInstance.auth.getSession();
        if (error) {
          addDebugInfo('post-init-session-error', { 
            error: error.message,
            time: new Date().toISOString() 
          });
        } else {
          addDebugInfo('post-init-test-success', { 
            hasSession: !!data.session,
            time: new Date().toISOString() 
          });
          localStorage.removeItem('auth-needs-reset');
        }
      } catch (e) {
        addDebugInfo('post-init-test-exception', {
          error: e.message,
          time: new Date().toISOString()
        });
      }
      
      initAttempts = 0;
      initLock = false;
      isInitializing = false;
      resolve(true);
    } catch (error: any) {
      addDebugInfo('critical-error', {
        message: error.message,
        stack: error.stack,
        time: new Date().toISOString()
      });
      localStorage.setItem('auth-needs-reset', 'true');
      initLock = false;
      isInitializing = false;
      initializationPromise = null;
      resolve(false);
    }
  });
  
  return initializationPromise;
};

// Function that waits for initialization
export const withInitializedClient = async <T>(action: () => Promise<T>): Promise<T> => {
  const startTime = new Date().toISOString();
  addDebugInfo('with-init-client', { time: startTime });
  const success = await initializeSecureClient();
  
  if (!success) {
    addDebugInfo('client-not-initialized', { time: new Date().toISOString() });
    
    // Clear initialization promise and retry with force reset
    initializationPromise = null;
    const retrySuccess = await initializeSecureClient(true);
    
    if (!retrySuccess) {
      throw new Error('Unable to initialize client after multiple attempts');
    }
  }
  
  addDebugInfo('client-ready-for-action', { time: new Date().toISOString() });
  return action();
};

// Enhanced function to clean up authentication state
export const cleanupAuthState = async () => {
  const startTime = new Date().toISOString();
  addDebugInfo('cleanup-start', {
    localStorage: Object.keys(localStorage),
    sessionStorage: Object.keys(sessionStorage),
    time: startTime
  });
  
  // Create a backup of local storage keys in case we need to restore some
  const backupKeys: Record<string, string> = {};
  
  try {
    // Get non-auth related keys that we want to preserve
    Object.keys(localStorage).forEach(key => {
      if (!key.startsWith('supabase.auth.') && !key.includes('sb-') && !key.includes('auth-')) {
        backupKeys[key] = localStorage.getItem(key) || '';
      }
    });
    
    addDebugInfo('backup-keys', {
      count: Object.keys(backupKeys).length,
      keys: Object.keys(backupKeys),
      time: new Date().toISOString()
    });
    
    // Actually clear everything for a complete reset
    localStorage.clear();
    sessionStorage.clear();
    
    // Restore non-auth related keys
    Object.keys(backupKeys).forEach(key => {
      localStorage.setItem(key, backupKeys[key]);
    });
    
    addDebugInfo('storage-cleared', {
      localStorage: Object.keys(localStorage),
      sessionStorage: Object.keys(sessionStorage),
      time: new Date().toISOString()
    });
  } catch (error: any) {
    addDebugInfo('storage-clear-error', {
      error: error.message,
      time: new Date().toISOString()
    });
    
    // Fallback: remove known auth keys explicitly
    Object.keys(localStorage).forEach((key) => {
      if (key.startsWith('supabase.auth.') || key.includes('sb-') || key.includes('auth-')) {
        addDebugInfo(`remove-local-${key}`, { time: new Date().toISOString() });
        localStorage.removeItem(key);
      }
    });

    // Do the same for sessionStorage
    Object.keys(sessionStorage).forEach((key) => {
      if (key.startsWith('supabase.auth.') || key.includes('sb-') || key.includes('auth-')) {
        addDebugInfo(`remove-session-${key}`, { time: new Date().toISOString() });
        sessionStorage.removeItem(key);
      }
    });
  }

  // Reset client
  supabaseInstance = null;
  initializationPromise = null;
  initLock = false;
  isInitializing = false;
  
  // Wait before reinitializing
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  addDebugInfo('cleanup-complete', { time: new Date().toISOString() });
  
  // Force client reinitialization
  return initializeSecureClient(true);
};

// Check if reset needed
export const needsAuthReset = (): boolean => {
  return localStorage.getItem('auth-needs-reset') === 'true';
};

// Get debug information
export const getDebugInfo = (): Record<string, any> => {
  return { ...debugStorage };
};

// Function to test direct connection to Edge Function
export const testEdgeFunctionConnection = async (): Promise<any> => {
  try {
    const cacheKiller = new Date().getTime();
    const randomId = Math.random().toString(36).substring(2, 15);
    
    // URL complète de l'Edge Function avec mode test
    const url = `${EDGE_FUNCTION_URL}?t=${cacheKiller}&testMode=true`;
    
    addDebugInfo("test-edge-function", { url, time: new Date().toISOString() });
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'X-Client-Info': `direct-test/v${cacheKiller}`,
        'X-Web-Security': 'allow',
        'X-Retry-Attempt': '1',
        'X-Client-Id': randomId,
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache'
      },
      cache: 'no-store',
      mode: 'cors'
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      addDebugInfo("test-edge-function-error", { 
        status: response.status, 
        statusText: response.statusText,
        body: errorText,
        time: new Date().toISOString()
      });
      return { 
        success: false, 
        status: response.status, 
        error: errorText 
      };
    }
    
    const result = await response.json();
    
    addDebugInfo("test-edge-function-result", { 
      status: response.status,
      result,
      headers: Object.fromEntries(response.headers.entries()),
      time: new Date().toISOString()
    });
    
    return {
      success: true,
      data: result
    };
  } catch (error: any) {
    addDebugInfo("test-edge-function-exception", { 
      error: error.message,
      stack: error.stack,
      time: new Date().toISOString() 
    });
    
    return {
      success: false,
      error: error.message
    };
  }
};

// Function to directly test connection to Supabase URL
export const testSupabaseConnection = async (): Promise<any> => {
  try {
    addDebugInfo("test-supabase-url", { url: SUPABASE_URL, time: new Date().toISOString() });
    
    const response = await fetch(`${SUPABASE_URL}/auth/v1/settings`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      cache: 'no-store',
      mode: 'cors'
    });
    
    const responseHeaders = Object.fromEntries(response.headers.entries());
    addDebugInfo("supabase-settings-response", { 
      status: response.status,
      statusText: response.statusText,
      headers: responseHeaders,
      time: new Date().toISOString() 
    });
    
    return {
      success: response.ok,
      status: response.status,
      statusText: response.statusText,
      headers: responseHeaders
    };
  } catch (error: any) {
    addDebugInfo("supabase-url-test-exception", { 
      error: error.message,
      stack: error.stack,
      time: new Date().toISOString() 
    });
    
    return {
      success: false,
      error: error.message
    };
  }
};
